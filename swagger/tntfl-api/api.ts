/**
 * TNTFL
 * Table Football Ladder
 *
 * OpenAPI spec version: 5.1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "http://www.int.corefiling.com/~tlr/tntfl".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
};

export interface Achievement {
    /**
     * Name of the achievement
     */
    "name": string;
    /**
     * A brief description of the achievement
     */
    "description": string;
    /**
     * Timestamp of when the achievement was earned
     */
    "time"?: number;
}

export interface AchievementCount {
    /**
     * Name of the achievement
     */
    "name": string;
    /**
     * A brief description of the achievement
     */
    "description": string;
    /**
     * Timestamp of when the achievement was earned
     */
    "time"?: number;
    /**
     * Number of times awarded
     */
    "count": number;
}

export interface ActivePlayers {
    "count": number;
}

export interface Belt {
    /**
     * Longest holder
     */
    "best": Streak;
    /**
     * Current holder
     */
    "current": Streak;
}

export interface Game {
    /**
     * The unix timestamp of when the game was added
     */
    "date": number;
    /**
     * Whether or not the players swapped ladder position
     */
    "positionSwap": boolean;
    "blue": Performance;
    "red": Performance;
    "deleted"?: GameDeleted;
}

export interface GameDeleted {
    /**
     * Unix time game was deleted at
     */
    "at": number;
    /**
     * User that deleted the game
     */
    "by": string;
}

export interface GamesLink {
    "href": string;
}

export interface GamesPerWeekItem {
    /**
     * Unix time
     */
    "date": number;
    "count": number;
}

export interface GlobalRecords {
    /**
     * Longest winning streak
     */
    "winningStreak": Streak;
    /**
     * Games with largest skill transfer
     */
    "mostSignificant": Array<Game>;
    /**
     * Games with smallest skill transfer
     */
    "leastSignificant": Array<Game>;
    /**
     * Games with most goals played
     */
    "longestGame": Game;
}

export interface GlobalTotals {
    /**
     * Number of games played
     */
    "games": number;
    /**
     * Number of players
     */
    "players": number;
    /**
     * Number of active players
     */
    "activePlayers": number;
    /**
     * Accumulated achievements
     */
    "achievements": Array<AchievementCount>;
}

export interface LadderEntry {
    /**
     * Player's rank
     */
    "rank"?: number;
    /**
     * Player's name
     */
    "name"?: string;
    /**
     * Player's skill
     */
    "skill"?: number;
    /**
     * Link to detailed player stats
     */
    "href"?: string;
    "player"?: Player;
    /**
     * Player's skill point trend
     */
    "trend"?: Array<TrendItem>;
}

export interface PerPlayerStat {
    /**
     * Opponent's ID
     */
    "opponent": string;
    /**
     * Skill transfer
     */
    "skillChange": number;
    /**
     * Goals scored
     */
    "for": number;
    /**
     * Goals conceded
     */
    "against": number;
    /**
     * Number of games
     */
    "games": number;
    /**
     * Number of wins
     */
    "wins": number;
    /**
     * Number of losses
     */
    "losses": number;
}

/**
 * Resource representing how a player performed in a game
 */
export interface Performance {
    /**
     * Player's cfl username
     */
    "name": string;
    /**
     * Goals scored by this player
     */
    "score": number;
    /**
     * Skill value change for this player
     */
    "skillChange": number;
    /**
     * Ladder rank change for this player
     */
    "rankChange": number;
    /**
     * New ladder rank of this player
     */
    "newRank": number;
    /**
     * Link to get player's information
     */
    "href": string;
    /**
     * Achievements earned during this performance
     */
    "achievements": Array<Achievement>;
}

/**
 * Resource representing information about a player
 */
export interface Player {
    /**
     * Player's cfl username
     */
    "name": string;
    /**
     * Player's current ladder rank
     */
    "rank": number;
    /**
     * Link to get all games for this player
     */
    "games": GamesLink;
    /**
     * Player's activity level
     */
    "activity": number;
    /**
     * The player's skill value in the ranking system
     */
    "skill": number;
    /**
     * Statistics for the player
     */
    "total": PlayerTotals;
}

export interface PlayerTotals {
    /**
     * The total number of goals the player has scored
     */
    "for": number;
    /**
     * The total number of goals scored against the player
     */
    "against": number;
    /**
     * The total number of games the player has won
     */
    "wins": number;
    /**
     * The total number of games the player has lost
     */
    "losses": number;
    /**
     * The total number of games the player has played
     */
    "games": number;
    /**
     * The total number of games the player has played so far today
     */
    "gamesToday"?: number;
    /**
     * The total number of games the player has played as red.
     */
    "gamesAsRed"?: number;
}

export interface Prediction {
    /**
     * Ratio of goals that blue is expected to score
     */
    "blueGoalRatio"?: number;
}

export interface Punditry {
    "facts": Array<string>;
}

export interface Speculated {
    /**
     * Ladder entries
     */
    "entries": Array<LadderEntry>;
    /**
     * Ladder entries
     */
    "games": Array<Game>;
}

export interface Stats {
    "totals": GlobalTotals;
    "records": GlobalRecords;
    "belt": Belt;
    "gamesPerWeek": Array<GamesPerWeekItem>;
}

export interface Streak {
    /**
     * The player's name
     */
    "player": string;
    /**
     * Length of streak
     */
    "count": number;
}

export interface TrendItem {
    /**
     * Unix time
     */
    "date": number;
    "skill": number;
}



/**
 * GamesApi - fetch parameter creator
 */
export const GamesApiFetchParamCreator = {
    /** 
     * Add a game
     * Add a game.
     * @param redPlayer The player on red
     * @param redScore The red team score
     * @param bluePlayer The player on blue
     * @param blueScore The blue team score
     */
    addGame(params: {  "redPlayer": string; "redScore": number; "bluePlayer": string; "blueScore": number; }, options?: any): FetchArgs {
        // verify required parameter "redPlayer" is set
        if (params["redPlayer"] == null) {
            throw new Error("Missing required parameter redPlayer when calling addGame");
        }
        // verify required parameter "redScore" is set
        if (params["redScore"] == null) {
            throw new Error("Missing required parameter redScore when calling addGame");
        }
        // verify required parameter "bluePlayer" is set
        if (params["bluePlayer"] == null) {
            throw new Error("Missing required parameter bluePlayer when calling addGame");
        }
        // verify required parameter "blueScore" is set
        if (params["blueScore"] == null) {
            throw new Error("Missing required parameter blueScore when calling addGame");
        }
        const baseUrl = `/game/add/json`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "redPlayer": params["redPlayer"],
            "redScore": params["redScore"],
            "bluePlayer": params["bluePlayer"],
            "blueScore": params["blueScore"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Add a game
     * Add a game.
     * @param redPlayer The player on red
     * @param redScore The red team score
     * @param bluePlayer The player on blue
     * @param blueScore The blue team score
     */
    addGameRedirect(params: {  "redPlayer": string; "redScore": number; "bluePlayer": string; "blueScore": number; }, options?: any): FetchArgs {
        // verify required parameter "redPlayer" is set
        if (params["redPlayer"] == null) {
            throw new Error("Missing required parameter redPlayer when calling addGameRedirect");
        }
        // verify required parameter "redScore" is set
        if (params["redScore"] == null) {
            throw new Error("Missing required parameter redScore when calling addGameRedirect");
        }
        // verify required parameter "bluePlayer" is set
        if (params["bluePlayer"] == null) {
            throw new Error("Missing required parameter bluePlayer when calling addGameRedirect");
        }
        // verify required parameter "blueScore" is set
        if (params["blueScore"] == null) {
            throw new Error("Missing required parameter blueScore when calling addGameRedirect");
        }
        const baseUrl = `/game/add`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "redPlayer": params["redPlayer"],
            "redScore": params["redScore"],
            "bluePlayer": params["bluePlayer"],
            "blueScore": params["blueScore"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a game
     * Get a game.
     * @param gameId Timestamp of the game
     */
    getGame(params: {  "gameId": number; }, options?: any): FetchArgs {
        // verify required parameter "gameId" is set
        if (params["gameId"] == null) {
            throw new Error("Missing required parameter gameId when calling getGame");
        }
        const baseUrl = `/game/{gameId}/json`
            .replace(`{${"gameId"}}`, `${ params["gameId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get games
     * Get games.
     * @param begin Timestamp to filter from.
     * @param end Timestamp to filter to.
     */
    getGames(params: {  "begin": number; "end": number; }, options?: any): FetchArgs {
        // verify required parameter "begin" is set
        if (params["begin"] == null) {
            throw new Error("Missing required parameter begin when calling getGames");
        }
        // verify required parameter "end" is set
        if (params["end"] == null) {
            throw new Error("Missing required parameter end when calling getGames");
        }
        const baseUrl = `/games/{begin}/{end}/json`
            .replace(`{${"begin"}}`, `${ params["begin"] }`)
            .replace(`{${"end"}}`, `${ params["end"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get shared games
     * Get shared games.
     * @param player1 Name of player 1
     * @param player2 Name of player 2
     */
    getHeadToHeadGames(params: {  "player1": string; "player2": string; }, options?: any): FetchArgs {
        // verify required parameter "player1" is set
        if (params["player1"] == null) {
            throw new Error("Missing required parameter player1 when calling getHeadToHeadGames");
        }
        // verify required parameter "player2" is set
        if (params["player2"] == null) {
            throw new Error("Missing required parameter player2 when calling getHeadToHeadGames");
        }
        const baseUrl = `/headtohead/{player1}/{player2}/games/json`
            .replace(`{${"player1"}}`, `${ params["player1"] }`)
            .replace(`{${"player2"}}`, `${ params["player2"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get game punditry
     * Get game punditry.
     * @param at CSV of timestamps
     */
    getPunditry(params: {  "at": string; }, options?: any): FetchArgs {
        // verify required parameter "at" is set
        if (params["at"] == null) {
            throw new Error("Missing required parameter at when calling getPunditry");
        }
        const baseUrl = `/pundit/json`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "at": params["at"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get recent games
     * Get recent games.
     * @param limit Maximum number of games to return
     */
    getRecent(params: {  "limit"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/recent/json`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "limit": params["limit"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Predict the outcome of a game
     * Predict the outcome of a game.
     * @param redElo Elo of red player
     * @param blueElo Elo of blue player
     */
    predict(params: {  "redElo": number; "blueElo": number; }, options?: any): FetchArgs {
        // verify required parameter "redElo" is set
        if (params["redElo"] == null) {
            throw new Error("Missing required parameter redElo when calling predict");
        }
        // verify required parameter "blueElo" is set
        if (params["blueElo"] == null) {
            throw new Error("Missing required parameter blueElo when calling predict");
        }
        const baseUrl = `/predict/{redElo}/{blueElo}/json`
            .replace(`{${"redElo"}}`, `${ params["redElo"] }`)
            .replace(`{${"blueElo"}}`, `${ params["blueElo"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * GamesApi - functional programming interface
 */
export const GamesApiFp = {
    /** 
     * Add a game
     * Add a game.
     * @param redPlayer The player on red
     * @param redScore The red team score
     * @param bluePlayer The player on blue
     * @param blueScore The blue team score
     */
    addGame(params: { "redPlayer": string; "redScore": number; "bluePlayer": string; "blueScore": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Game> {
        const fetchArgs = GamesApiFetchParamCreator.addGame(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Add a game
     * Add a game.
     * @param redPlayer The player on red
     * @param redScore The red team score
     * @param bluePlayer The player on blue
     * @param blueScore The blue team score
     */
    addGameRedirect(params: { "redPlayer": string; "redScore": number; "bluePlayer": string; "blueScore": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamesApiFetchParamCreator.addGameRedirect(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a game
     * Get a game.
     * @param gameId Timestamp of the game
     */
    getGame(params: { "gameId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Game> {
        const fetchArgs = GamesApiFetchParamCreator.getGame(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get games
     * Get games.
     * @param begin Timestamp to filter from.
     * @param end Timestamp to filter to.
     */
    getGames(params: { "begin": number; "end": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Game>> {
        const fetchArgs = GamesApiFetchParamCreator.getGames(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get shared games
     * Get shared games.
     * @param player1 Name of player 1
     * @param player2 Name of player 2
     */
    getHeadToHeadGames(params: { "player1": string; "player2": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Game>> {
        const fetchArgs = GamesApiFetchParamCreator.getHeadToHeadGames(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get game punditry
     * Get game punditry.
     * @param at CSV of timestamps
     */
    getPunditry(params: { "at": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: Punditry; }> {
        const fetchArgs = GamesApiFetchParamCreator.getPunditry(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get recent games
     * Get recent games.
     * @param limit Maximum number of games to return
     */
    getRecent(params: { "limit"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Game>> {
        const fetchArgs = GamesApiFetchParamCreator.getRecent(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Predict the outcome of a game
     * Predict the outcome of a game.
     * @param redElo Elo of red player
     * @param blueElo Elo of blue player
     */
    predict(params: { "redElo": number; "blueElo": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Prediction> {
        const fetchArgs = GamesApiFetchParamCreator.predict(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * GamesApi - object-oriented interface
 */
export class GamesApi extends BaseAPI {
    /** 
     * Add a game
     * Add a game.
     * @param redPlayer The player on red
     * @param redScore The red team score
     * @param bluePlayer The player on blue
     * @param blueScore The blue team score
     */
    addGame(params: {  "redPlayer": string; "redScore": number; "bluePlayer": string; "blueScore": number; }, options?: any) {
        return GamesApiFp.addGame(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Add a game
     * Add a game.
     * @param redPlayer The player on red
     * @param redScore The red team score
     * @param bluePlayer The player on blue
     * @param blueScore The blue team score
     */
    addGameRedirect(params: {  "redPlayer": string; "redScore": number; "bluePlayer": string; "blueScore": number; }, options?: any) {
        return GamesApiFp.addGameRedirect(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get a game
     * Get a game.
     * @param gameId Timestamp of the game
     */
    getGame(params: {  "gameId": number; }, options?: any) {
        return GamesApiFp.getGame(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get games
     * Get games.
     * @param begin Timestamp to filter from.
     * @param end Timestamp to filter to.
     */
    getGames(params: {  "begin": number; "end": number; }, options?: any) {
        return GamesApiFp.getGames(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get shared games
     * Get shared games.
     * @param player1 Name of player 1
     * @param player2 Name of player 2
     */
    getHeadToHeadGames(params: {  "player1": string; "player2": string; }, options?: any) {
        return GamesApiFp.getHeadToHeadGames(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get game punditry
     * Get game punditry.
     * @param at CSV of timestamps
     */
    getPunditry(params: {  "at": string; }, options?: any) {
        return GamesApiFp.getPunditry(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get recent games
     * Get recent games.
     * @param limit Maximum number of games to return
     */
    getRecent(params: {  "limit"?: number; }, options?: any) {
        return GamesApiFp.getRecent(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Predict the outcome of a game
     * Predict the outcome of a game.
     * @param redElo Elo of red player
     * @param blueElo Elo of blue player
     */
    predict(params: {  "redElo": number; "blueElo": number; }, options?: any) {
        return GamesApiFp.predict(params, options)(this.fetch, this.basePath);
    }
};

/**
 * GamesApi - factory interface
 */
export const GamesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Add a game
         * Add a game.
         * @param redPlayer The player on red
         * @param redScore The red team score
         * @param bluePlayer The player on blue
         * @param blueScore The blue team score
         */
        addGame(params: {  "redPlayer": string; "redScore": number; "bluePlayer": string; "blueScore": number; }, options?: any) {
            return GamesApiFp.addGame(params, options)(fetch, basePath);
        },
        /** 
         * Add a game
         * Add a game.
         * @param redPlayer The player on red
         * @param redScore The red team score
         * @param bluePlayer The player on blue
         * @param blueScore The blue team score
         */
        addGameRedirect(params: {  "redPlayer": string; "redScore": number; "bluePlayer": string; "blueScore": number; }, options?: any) {
            return GamesApiFp.addGameRedirect(params, options)(fetch, basePath);
        },
        /** 
         * Get a game
         * Get a game.
         * @param gameId Timestamp of the game
         */
        getGame(params: {  "gameId": number; }, options?: any) {
            return GamesApiFp.getGame(params, options)(fetch, basePath);
        },
        /** 
         * Get games
         * Get games.
         * @param begin Timestamp to filter from.
         * @param end Timestamp to filter to.
         */
        getGames(params: {  "begin": number; "end": number; }, options?: any) {
            return GamesApiFp.getGames(params, options)(fetch, basePath);
        },
        /** 
         * Get shared games
         * Get shared games.
         * @param player1 Name of player 1
         * @param player2 Name of player 2
         */
        getHeadToHeadGames(params: {  "player1": string; "player2": string; }, options?: any) {
            return GamesApiFp.getHeadToHeadGames(params, options)(fetch, basePath);
        },
        /** 
         * Get game punditry
         * Get game punditry.
         * @param at CSV of timestamps
         */
        getPunditry(params: {  "at": string; }, options?: any) {
            return GamesApiFp.getPunditry(params, options)(fetch, basePath);
        },
        /** 
         * Get recent games
         * Get recent games.
         * @param limit Maximum number of games to return
         */
        getRecent(params: {  "limit"?: number; }, options?: any) {
            return GamesApiFp.getRecent(params, options)(fetch, basePath);
        },
        /** 
         * Predict the outcome of a game
         * Predict the outcome of a game.
         * @param redElo Elo of red player
         * @param blueElo Elo of blue player
         */
        predict(params: {  "redElo": number; "blueElo": number; }, options?: any) {
            return GamesApiFp.predict(params, options)(fetch, basePath);
        },
    };
};


/**
 * LadderApi - fetch parameter creator
 */
export const LadderApiFetchParamCreator = {
    /** 
     * Get the ladder
     * Get the ladder.
     * @param showInactive Include inactive players
     * @param players Include detailed player info
     */
    getLadder(params: {  "showInactive"?: number; "players"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/ladder/json`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "showInactive": params["showInactive"],
            "players": params["players"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get the ladder
     * Get the ladder.
     * @param begin Timestamp to filter from.
     * @param end Timestamp to filter to.
     * @param showInactive Include inactive players
     * @param players Include detailed player info
     */
    getLadderBetween(params: {  "begin": number; "end": number; "showInactive"?: number; "players"?: number; }, options?: any): FetchArgs {
        // verify required parameter "begin" is set
        if (params["begin"] == null) {
            throw new Error("Missing required parameter begin when calling getLadderBetween");
        }
        // verify required parameter "end" is set
        if (params["end"] == null) {
            throw new Error("Missing required parameter end when calling getLadderBetween");
        }
        const baseUrl = `/ladder/{begin}/{end}/json`
            .replace(`{${"begin"}}`, `${ params["begin"] }`)
            .replace(`{${"end"}}`, `${ params["end"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "showInactive": params["showInactive"],
            "players": params["players"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get the ladder
     * Get the ladder.
     * @param showInactive Include inactive players
     * @param players Include detailed player info
     * @param previousGames CSV of speculative games
     */
    speculate(params: {  "showInactive"?: number; "players"?: number; "previousGames"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/speculate/json`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "showInactive": params["showInactive"],
            "players": params["players"],
            "previousGames": params["previousGames"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * LadderApi - functional programming interface
 */
export const LadderApiFp = {
    /** 
     * Get the ladder
     * Get the ladder.
     * @param showInactive Include inactive players
     * @param players Include detailed player info
     */
    getLadder(params: { "showInactive"?: number; "players"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LadderEntry>> {
        const fetchArgs = LadderApiFetchParamCreator.getLadder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get the ladder
     * Get the ladder.
     * @param begin Timestamp to filter from.
     * @param end Timestamp to filter to.
     * @param showInactive Include inactive players
     * @param players Include detailed player info
     */
    getLadderBetween(params: { "begin": number; "end": number; "showInactive"?: number; "players"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LadderEntry>> {
        const fetchArgs = LadderApiFetchParamCreator.getLadderBetween(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get the ladder
     * Get the ladder.
     * @param showInactive Include inactive players
     * @param players Include detailed player info
     * @param previousGames CSV of speculative games
     */
    speculate(params: { "showInactive"?: number; "players"?: number; "previousGames"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Speculated> {
        const fetchArgs = LadderApiFetchParamCreator.speculate(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * LadderApi - object-oriented interface
 */
export class LadderApi extends BaseAPI {
    /** 
     * Get the ladder
     * Get the ladder.
     * @param showInactive Include inactive players
     * @param players Include detailed player info
     */
    getLadder(params: {  "showInactive"?: number; "players"?: number; }, options?: any) {
        return LadderApiFp.getLadder(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get the ladder
     * Get the ladder.
     * @param begin Timestamp to filter from.
     * @param end Timestamp to filter to.
     * @param showInactive Include inactive players
     * @param players Include detailed player info
     */
    getLadderBetween(params: {  "begin": number; "end": number; "showInactive"?: number; "players"?: number; }, options?: any) {
        return LadderApiFp.getLadderBetween(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get the ladder
     * Get the ladder.
     * @param showInactive Include inactive players
     * @param players Include detailed player info
     * @param previousGames CSV of speculative games
     */
    speculate(params: {  "showInactive"?: number; "players"?: number; "previousGames"?: string; }, options?: any) {
        return LadderApiFp.speculate(params, options)(this.fetch, this.basePath);
    }
};

/**
 * LadderApi - factory interface
 */
export const LadderApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Get the ladder
         * Get the ladder.
         * @param showInactive Include inactive players
         * @param players Include detailed player info
         */
        getLadder(params: {  "showInactive"?: number; "players"?: number; }, options?: any) {
            return LadderApiFp.getLadder(params, options)(fetch, basePath);
        },
        /** 
         * Get the ladder
         * Get the ladder.
         * @param begin Timestamp to filter from.
         * @param end Timestamp to filter to.
         * @param showInactive Include inactive players
         * @param players Include detailed player info
         */
        getLadderBetween(params: {  "begin": number; "end": number; "showInactive"?: number; "players"?: number; }, options?: any) {
            return LadderApiFp.getLadderBetween(params, options)(fetch, basePath);
        },
        /** 
         * Get the ladder
         * Get the ladder.
         * @param showInactive Include inactive players
         * @param players Include detailed player info
         * @param previousGames CSV of speculative games
         */
        speculate(params: {  "showInactive"?: number; "players"?: number; "previousGames"?: string; }, options?: any) {
            return LadderApiFp.speculate(params, options)(fetch, basePath);
        },
    };
};


/**
 * PlayersApi - fetch parameter creator
 */
export const PlayersApiFetchParamCreator = {
    /** 
     * Get number of active players
     * Get number of active players.
     * @param at CSV of timestamps
     */
    getActive(params: {  "at"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/activeplayers/json`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "at": params["at"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get per player stats
     * Get per player stats.
     * @param player ID of the player
     */
    getPerPlayerStats(params: {  "player": string; }, options?: any): FetchArgs {
        // verify required parameter "player" is set
        if (params["player"] == null) {
            throw new Error("Missing required parameter player when calling getPerPlayerStats");
        }
        const baseUrl = `/player/{player}/perplayerstats/json`
            .replace(`{${"player"}}`, `${ params["player"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get player info
     * Get player info.
     * @param player ID of the player
     */
    getPlayer(params: {  "player": string; }, options?: any): FetchArgs {
        // verify required parameter "player" is set
        if (params["player"] == null) {
            throw new Error("Missing required parameter player when calling getPlayer");
        }
        const baseUrl = `/player/{player}/json`
            .replace(`{${"player"}}`, `${ params["player"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get player&#39;s achievements
     * Get player&#39;s achievements.
     * @param player ID of the player
     */
    getPlayerAchievements(params: {  "player": string; }, options?: any): FetchArgs {
        // verify required parameter "player" is set
        if (params["player"] == null) {
            throw new Error("Missing required parameter player when calling getPlayerAchievements");
        }
        const baseUrl = `/player/{player}/achievements/json`
            .replace(`{${"player"}}`, `${ params["player"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get player&#39;s games
     * Get player&#39;s games.
     * @param player ID of the player
     */
    getPlayerGames(params: {  "player": string; }, options?: any): FetchArgs {
        // verify required parameter "player" is set
        if (params["player"] == null) {
            throw new Error("Missing required parameter player when calling getPlayerGames");
        }
        const baseUrl = `/player/{player}/games/json`
            .replace(`{${"player"}}`, `${ params["player"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PlayersApi - functional programming interface
 */
export const PlayersApiFp = {
    /** 
     * Get number of active players
     * Get number of active players.
     * @param at CSV of timestamps
     */
    getActive(params: { "at"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: ActivePlayers; }> {
        const fetchArgs = PlayersApiFetchParamCreator.getActive(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get per player stats
     * Get per player stats.
     * @param player ID of the player
     */
    getPerPlayerStats(params: { "player": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PerPlayerStat>> {
        const fetchArgs = PlayersApiFetchParamCreator.getPerPlayerStats(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get player info
     * Get player info.
     * @param player ID of the player
     */
    getPlayer(params: { "player": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Player> {
        const fetchArgs = PlayersApiFetchParamCreator.getPlayer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get player&#39;s achievements
     * Get player&#39;s achievements.
     * @param player ID of the player
     */
    getPlayerAchievements(params: { "player": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Achievement>> {
        const fetchArgs = PlayersApiFetchParamCreator.getPlayerAchievements(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get player&#39;s games
     * Get player&#39;s games.
     * @param player ID of the player
     */
    getPlayerGames(params: { "player": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Game>> {
        const fetchArgs = PlayersApiFetchParamCreator.getPlayerGames(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PlayersApi - object-oriented interface
 */
export class PlayersApi extends BaseAPI {
    /** 
     * Get number of active players
     * Get number of active players.
     * @param at CSV of timestamps
     */
    getActive(params: {  "at"?: string; }, options?: any) {
        return PlayersApiFp.getActive(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get per player stats
     * Get per player stats.
     * @param player ID of the player
     */
    getPerPlayerStats(params: {  "player": string; }, options?: any) {
        return PlayersApiFp.getPerPlayerStats(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get player info
     * Get player info.
     * @param player ID of the player
     */
    getPlayer(params: {  "player": string; }, options?: any) {
        return PlayersApiFp.getPlayer(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get player&#39;s achievements
     * Get player&#39;s achievements.
     * @param player ID of the player
     */
    getPlayerAchievements(params: {  "player": string; }, options?: any) {
        return PlayersApiFp.getPlayerAchievements(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get player&#39;s games
     * Get player&#39;s games.
     * @param player ID of the player
     */
    getPlayerGames(params: {  "player": string; }, options?: any) {
        return PlayersApiFp.getPlayerGames(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PlayersApi - factory interface
 */
export const PlayersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Get number of active players
         * Get number of active players.
         * @param at CSV of timestamps
         */
        getActive(params: {  "at"?: string; }, options?: any) {
            return PlayersApiFp.getActive(params, options)(fetch, basePath);
        },
        /** 
         * Get per player stats
         * Get per player stats.
         * @param player ID of the player
         */
        getPerPlayerStats(params: {  "player": string; }, options?: any) {
            return PlayersApiFp.getPerPlayerStats(params, options)(fetch, basePath);
        },
        /** 
         * Get player info
         * Get player info.
         * @param player ID of the player
         */
        getPlayer(params: {  "player": string; }, options?: any) {
            return PlayersApiFp.getPlayer(params, options)(fetch, basePath);
        },
        /** 
         * Get player&#39;s achievements
         * Get player&#39;s achievements.
         * @param player ID of the player
         */
        getPlayerAchievements(params: {  "player": string; }, options?: any) {
            return PlayersApiFp.getPlayerAchievements(params, options)(fetch, basePath);
        },
        /** 
         * Get player&#39;s games
         * Get player&#39;s games.
         * @param player ID of the player
         */
        getPlayerGames(params: {  "player": string; }, options?: any) {
            return PlayersApiFp.getPlayerGames(params, options)(fetch, basePath);
        },
    };
};


/**
 * StatsApi - fetch parameter creator
 */
export const StatsApiFetchParamCreator = {
    /** 
     * Get global stats
     * Get global stats.
     */
    getStats(options?: any): FetchArgs {
        const baseUrl = `/stats/json`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StatsApi - functional programming interface
 */
export const StatsApiFp = {
    /** 
     * Get global stats
     * Get global stats.
     */
    getStats(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Stats> {
        const fetchArgs = StatsApiFetchParamCreator.getStats(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StatsApi - object-oriented interface
 */
export class StatsApi extends BaseAPI {
    /** 
     * Get global stats
     * Get global stats.
     */
    getStats(options?: any) {
        return StatsApiFp.getStats(options)(this.fetch, this.basePath);
    }
};

/**
 * StatsApi - factory interface
 */
export const StatsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Get global stats
         * Get global stats.
         */
        getStats(options?: any) {
            return StatsApiFp.getStats(options)(fetch, basePath);
        },
    };
};

