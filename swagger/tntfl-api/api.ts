/**
 * TNTFL
 * Table Football Ladder
 *
 * OpenAPI spec version: 5.1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "http://www.int.corefiling.com/~tlr/tntfl";

export interface FetchArgs {
    url: string;
    options: any; 
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
}

export interface Achievement {
    /**
     * Name of the achievement
     */
    "name": string;
    /**
     * A brief description of the achievement
     */
    "description": string;
    /**
     * Timestamp of when the achievement was earned
     */
    "time"?: number;
}

export interface AchievementCount {
    /**
     * Name of the achievement
     */
    "name": string;
    /**
     * A brief description of the achievement
     */
    "description": string;
    /**
     * Timestamp of when the achievement was earned
     */
    "time"?: number;
    /**
     * Number of times awarded
     */
    "count": number;
}

export interface ActivePlayers {
    "count": number;
}

export interface Belt {
    /**
     * Longest holder
     */
    "best": Streak;
    /**
     * Current holder
     */
    "current": Streak;
}

export interface Game {
    /**
     * The unix timestamp of when the game was added
     */
    "date": number;
    /**
     * Whether or not the players swapped ladder position
     */
    "positionSwap": boolean;
    "blue": Performance;
    "red": Performance;
    "deleted"?: GameDeleted;
}

export interface GameDeleted {
    /**
     * Unix time game was deleted at
     */
    "at": number;
    /**
     * User that deleted the game
     */
    "by": string;
}

export interface GamesLink {
    "href": string;
}

export interface GamesPerWeekItem {
    /**
     * Unix time
     */
    "date": number;
    "count": number;
}

export interface GlobalRecords {
    /**
     * Longest winning streak
     */
    "winningStreak": Streak;
    /**
     * Games with largest skill transfer
     */
    "mostSignificant": Array<Game>;
    /**
     * Games with smallest skill transfer
     */
    "leastSignificant": Array<Game>;
    /**
     * Games with most goals played
     */
    "longestGame": Game;
}

export interface GlobalTotals {
    /**
     * Number of games played
     */
    "games": number;
    /**
     * Number of players
     */
    "players": number;
    /**
     * Number of active players
     */
    "activePlayers": number;
    /**
     * Accumulated achievements
     */
    "achievements": Array<AchievementCount>;
}

export interface LadderEntry {
    /**
     * Player's rank
     */
    "rank"?: number;
    /**
     * Player's name
     */
    "name"?: string;
    /**
     * Player's skill
     */
    "skill"?: number;
    /**
     * Link to detailed player stats
     */
    "href"?: string;
    "player"?: Player;
    /**
     * Player's skill point trend
     */
    "trend"?: Array<TrendItem>;
}

export interface PerPlayerStat {
    /**
     * Opponent's ID
     */
    "opponent": string;
    /**
     * Skill transfer
     */
    "skillChange": number;
    /**
     * Goals scored
     */
    "for": number;
    /**
     * Goals conceded
     */
    "against": number;
    /**
     * Number of games
     */
    "games": number;
    /**
     * Number of wins
     */
    "wins": number;
    /**
     * Number of losses
     */
    "losses": number;
}

/**
 * Resource representing how a player performed in a game
 */
export interface Performance {
    /**
     * Player's cfl username
     */
    "name": string;
    /**
     * Goals scored by this player
     */
    "score": number;
    /**
     * Skill value change for this player
     */
    "skillChange": number;
    /**
     * Ladder rank change for this player
     */
    "rankChange": number;
    /**
     * New ladder rank of this player
     */
    "newRank": number;
    /**
     * Link to get player's information
     */
    "href": string;
    /**
     * Achievements earned during this performance
     */
    "achievements": Array<Achievement>;
}

/**
 * Resource representing information about a player
 */
export interface Player {
    /**
     * Player's cfl username
     */
    "name": string;
    /**
     * Player's current ladder rank
     */
    "rank": number;
    /**
     * Link to get all games for this player
     */
    "games": GamesLink;
    /**
     * Whether or not the system considers the player active
     */
    "active": boolean;
    /**
     * The player's skill value in the ranking system
     */
    "skill": number;
    /**
     * Statistics for the player
     */
    "total": PlayerTotals;
}

export interface PlayerTotals {
    /**
     * The total number of goals the player has scored
     */
    "for": number;
    /**
     * The total number of goals scored against the player
     */
    "against": number;
    /**
     * The total number of games the player has won
     */
    "wins": number;
    /**
     * The total number of games the player has lost
     */
    "losses": number;
    /**
     * The total number of games the player has played
     */
    "games": number;
    /**
     * The total number of games the player has played so far today
     */
    "gamesToday"?: number;
    /**
     * The total number of games the player has played as red.
     */
    "gamesAsRed"?: number;
}

export interface Prediction {
    /**
     * Ratio of goals that blue is expected to score
     */
    "blueGoalRatio"?: number;
}

export interface Speculated {
    /**
     * Ladder entries
     */
    "entries": Array<LadderEntry>;
    /**
     * Ladder entries
     */
    "games": Array<Game>;
}

export interface Stats {
    "totals": GlobalTotals;
    "records": GlobalRecords;
    "belt": Belt;
    "gamesPerWeek": Array<GamesPerWeekItem>;
}

export interface Streak {
    /**
     * The player's name
     */
    "player": string;
    /**
     * Length of streak
     */
    "count": number;
}

export interface TrendItem {
    /**
     * Unix time
     */
    "date": number;
    "skill": number;
}



/**
 * GamesApi - fetch parameter creator
 */
export const GamesApiFetchParamCreactor = {
    /** 
     * Add a game
     * Add a game.
     * @param redPlayer The player on red
     * @param redScore The red team score
     * @param bluePlayer The player on blue
     * @param blueScore The blue team score
     */
    addGame(params: {  redPlayer: string; redScore: number; bluePlayer: string; blueScore: number; }): FetchArgs {
        // verify required parameter "redPlayer" is set
        if (params["redPlayer"] == null) {
            throw new Error("Missing required parameter redPlayer when calling addGame");
        }
        // verify required parameter "redScore" is set
        if (params["redScore"] == null) {
            throw new Error("Missing required parameter redScore when calling addGame");
        }
        // verify required parameter "bluePlayer" is set
        if (params["bluePlayer"] == null) {
            throw new Error("Missing required parameter bluePlayer when calling addGame");
        }
        // verify required parameter "blueScore" is set
        if (params["blueScore"] == null) {
            throw new Error("Missing required parameter blueScore when calling addGame");
        }
        const baseUrl = `/game/add/json`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "redPlayer": params.redPlayer,
            "redScore": params.redScore,
            "bluePlayer": params.bluePlayer,
            "blueScore": params.blueScore,
        });
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Add a game
     * Add a game.
     * @param redPlayer The player on red
     * @param redScore The red team score
     * @param bluePlayer The player on blue
     * @param blueScore The blue team score
     */
    addGameRedirect(params: {  redPlayer: string; redScore: number; bluePlayer: string; blueScore: number; }): FetchArgs {
        // verify required parameter "redPlayer" is set
        if (params["redPlayer"] == null) {
            throw new Error("Missing required parameter redPlayer when calling addGameRedirect");
        }
        // verify required parameter "redScore" is set
        if (params["redScore"] == null) {
            throw new Error("Missing required parameter redScore when calling addGameRedirect");
        }
        // verify required parameter "bluePlayer" is set
        if (params["bluePlayer"] == null) {
            throw new Error("Missing required parameter bluePlayer when calling addGameRedirect");
        }
        // verify required parameter "blueScore" is set
        if (params["blueScore"] == null) {
            throw new Error("Missing required parameter blueScore when calling addGameRedirect");
        }
        const baseUrl = `/game/add`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "redPlayer": params.redPlayer,
            "redScore": params.redScore,
            "bluePlayer": params.bluePlayer,
            "blueScore": params.blueScore,
        });
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get a game
     * Get a game.
     * @param gameId Timestamp of the game
     */
    getGame(params: {  gameId: number; }): FetchArgs {
        // verify required parameter "gameId" is set
        if (params["gameId"] == null) {
            throw new Error("Missing required parameter gameId when calling getGame");
        }
        const baseUrl = `/game/{gameId}/json`
            .replace(`{${"gameId"}}`, `${ params.gameId }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get games
     * Get games.
     * @param begin Timestamp to filter from.
     * @param end Timestamp to filter to.
     */
    getGames(params: {  begin: number; end: number; }): FetchArgs {
        // verify required parameter "begin" is set
        if (params["begin"] == null) {
            throw new Error("Missing required parameter begin when calling getGames");
        }
        // verify required parameter "end" is set
        if (params["end"] == null) {
            throw new Error("Missing required parameter end when calling getGames");
        }
        const baseUrl = `/games/{begin}/{end}/json`
            .replace(`{${"begin"}}`, `${ params.begin }`)
            .replace(`{${"end"}}`, `${ params.end }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get shared games
     * Get shared games.
     * @param player1 Name of player 1
     * @param player2 Name of player 2
     */
    getHeadToHeadGames(params: {  player1: string; player2: string; }): FetchArgs {
        // verify required parameter "player1" is set
        if (params["player1"] == null) {
            throw new Error("Missing required parameter player1 when calling getHeadToHeadGames");
        }
        // verify required parameter "player2" is set
        if (params["player2"] == null) {
            throw new Error("Missing required parameter player2 when calling getHeadToHeadGames");
        }
        const baseUrl = `/headtohead/{player1}/{player2}/games/json`
            .replace(`{${"player1"}}`, `${ params.player1 }`)
            .replace(`{${"player2"}}`, `${ params.player2 }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get game punditry
     * Get game punditry.
     * @param gameId Timestamp of game
     */
    getPunditry(params: {  gameId: number; }): FetchArgs {
        // verify required parameter "gameId" is set
        if (params["gameId"] == null) {
            throw new Error("Missing required parameter gameId when calling getPunditry");
        }
        const baseUrl = `/pundit/{gameId}/json`
            .replace(`{${"gameId"}}`, `${ params.gameId }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get recent games
     * Get recent games.
     * @param limit Maximum number of games to return
     */
    getRecent(params: {  limit?: number; }): FetchArgs {
        const baseUrl = `/recent/json`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "limit": params.limit,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Predict the outcome of a game
     * Predict the outcome of a game.
     * @param redElo Elo of red player
     * @param blueElo Elo of blue player
     */
    predict(params: {  redElo: number; blueElo: number; }): FetchArgs {
        // verify required parameter "redElo" is set
        if (params["redElo"] == null) {
            throw new Error("Missing required parameter redElo when calling predict");
        }
        // verify required parameter "blueElo" is set
        if (params["blueElo"] == null) {
            throw new Error("Missing required parameter blueElo when calling predict");
        }
        const baseUrl = `/predict/{redElo}/{blueElo}/json`
            .replace(`{${"redElo"}}`, `${ params.redElo }`)
            .replace(`{${"blueElo"}}`, `${ params.blueElo }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * GamesApi - functional programming interface
 */
export const GamesApiFp = {
    /** 
     * Add a game
     * Add a game.
     * @param redPlayer The player on red
     * @param redScore The red team score
     * @param bluePlayer The player on blue
     * @param blueScore The blue team score
     */
    addGame(params: { redPlayer: string; redScore: number; bluePlayer: string; blueScore: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<Game> {
        const fetchArgs = GamesApiFetchParamCreactor.addGame(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Add a game
     * Add a game.
     * @param redPlayer The player on red
     * @param redScore The red team score
     * @param bluePlayer The player on blue
     * @param blueScore The blue team score
     */
    addGameRedirect(params: { redPlayer: string; redScore: number; bluePlayer: string; blueScore: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = GamesApiFetchParamCreactor.addGameRedirect(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get a game
     * Get a game.
     * @param gameId Timestamp of the game
     */
    getGame(params: { gameId: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<Game> {
        const fetchArgs = GamesApiFetchParamCreactor.getGame(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get games
     * Get games.
     * @param begin Timestamp to filter from.
     * @param end Timestamp to filter to.
     */
    getGames(params: { begin: number; end: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<Array<Game>> {
        const fetchArgs = GamesApiFetchParamCreactor.getGames(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get shared games
     * Get shared games.
     * @param player1 Name of player 1
     * @param player2 Name of player 2
     */
    getHeadToHeadGames(params: { player1: string; player2: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<Array<Game>> {
        const fetchArgs = GamesApiFetchParamCreactor.getHeadToHeadGames(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get game punditry
     * Get game punditry.
     * @param gameId Timestamp of game
     */
    getPunditry(params: { gameId: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = GamesApiFetchParamCreactor.getPunditry(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get recent games
     * Get recent games.
     * @param limit Maximum number of games to return
     */
    getRecent(params: { limit?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<Array<Game>> {
        const fetchArgs = GamesApiFetchParamCreactor.getRecent(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Predict the outcome of a game
     * Predict the outcome of a game.
     * @param redElo Elo of red player
     * @param blueElo Elo of blue player
     */
    predict(params: { redElo: number; blueElo: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<Prediction> {
        const fetchArgs = GamesApiFetchParamCreactor.predict(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * GamesApi - object-oriented interface
 */
export class GamesApi extends BaseAPI {
    /** 
     * Add a game
     * Add a game.
     * @param redPlayer The player on red
     * @param redScore The red team score
     * @param bluePlayer The player on blue
     * @param blueScore The blue team score
     */
    addGame(params: {  redPlayer: string; redScore: number; bluePlayer: string; blueScore: number; }) {
        return GamesApiFp.addGame(params)(this.fetch, this.basePath);
    }
    /** 
     * Add a game
     * Add a game.
     * @param redPlayer The player on red
     * @param redScore The red team score
     * @param bluePlayer The player on blue
     * @param blueScore The blue team score
     */
    addGameRedirect(params: {  redPlayer: string; redScore: number; bluePlayer: string; blueScore: number; }) {
        return GamesApiFp.addGameRedirect(params)(this.fetch, this.basePath);
    }
    /** 
     * Get a game
     * Get a game.
     * @param gameId Timestamp of the game
     */
    getGame(params: {  gameId: number; }) {
        return GamesApiFp.getGame(params)(this.fetch, this.basePath);
    }
    /** 
     * Get games
     * Get games.
     * @param begin Timestamp to filter from.
     * @param end Timestamp to filter to.
     */
    getGames(params: {  begin: number; end: number; }) {
        return GamesApiFp.getGames(params)(this.fetch, this.basePath);
    }
    /** 
     * Get shared games
     * Get shared games.
     * @param player1 Name of player 1
     * @param player2 Name of player 2
     */
    getHeadToHeadGames(params: {  player1: string; player2: string; }) {
        return GamesApiFp.getHeadToHeadGames(params)(this.fetch, this.basePath);
    }
    /** 
     * Get game punditry
     * Get game punditry.
     * @param gameId Timestamp of game
     */
    getPunditry(params: {  gameId: number; }) {
        return GamesApiFp.getPunditry(params)(this.fetch, this.basePath);
    }
    /** 
     * Get recent games
     * Get recent games.
     * @param limit Maximum number of games to return
     */
    getRecent(params: {  limit?: number; }) {
        return GamesApiFp.getRecent(params)(this.fetch, this.basePath);
    }
    /** 
     * Predict the outcome of a game
     * Predict the outcome of a game.
     * @param redElo Elo of red player
     * @param blueElo Elo of blue player
     */
    predict(params: {  redElo: number; blueElo: number; }) {
        return GamesApiFp.predict(params)(this.fetch, this.basePath);
    }
};

/**
 * GamesApi - factory interface
 */
export const GamesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Add a game
         * Add a game.
         * @param redPlayer The player on red
         * @param redScore The red team score
         * @param bluePlayer The player on blue
         * @param blueScore The blue team score
         */
        addGame(params: {  redPlayer: string; redScore: number; bluePlayer: string; blueScore: number; }) {
            return GamesApiFp.addGame(params)(fetch, basePath);
        },
        /** 
         * Add a game
         * Add a game.
         * @param redPlayer The player on red
         * @param redScore The red team score
         * @param bluePlayer The player on blue
         * @param blueScore The blue team score
         */
        addGameRedirect(params: {  redPlayer: string; redScore: number; bluePlayer: string; blueScore: number; }) {
            return GamesApiFp.addGameRedirect(params)(fetch, basePath);
        },
        /** 
         * Get a game
         * Get a game.
         * @param gameId Timestamp of the game
         */
        getGame(params: {  gameId: number; }) {
            return GamesApiFp.getGame(params)(fetch, basePath);
        },
        /** 
         * Get games
         * Get games.
         * @param begin Timestamp to filter from.
         * @param end Timestamp to filter to.
         */
        getGames(params: {  begin: number; end: number; }) {
            return GamesApiFp.getGames(params)(fetch, basePath);
        },
        /** 
         * Get shared games
         * Get shared games.
         * @param player1 Name of player 1
         * @param player2 Name of player 2
         */
        getHeadToHeadGames(params: {  player1: string; player2: string; }) {
            return GamesApiFp.getHeadToHeadGames(params)(fetch, basePath);
        },
        /** 
         * Get game punditry
         * Get game punditry.
         * @param gameId Timestamp of game
         */
        getPunditry(params: {  gameId: number; }) {
            return GamesApiFp.getPunditry(params)(fetch, basePath);
        },
        /** 
         * Get recent games
         * Get recent games.
         * @param limit Maximum number of games to return
         */
        getRecent(params: {  limit?: number; }) {
            return GamesApiFp.getRecent(params)(fetch, basePath);
        },
        /** 
         * Predict the outcome of a game
         * Predict the outcome of a game.
         * @param redElo Elo of red player
         * @param blueElo Elo of blue player
         */
        predict(params: {  redElo: number; blueElo: number; }) {
            return GamesApiFp.predict(params)(fetch, basePath);
        },
    }
};


/**
 * LadderApi - fetch parameter creator
 */
export const LadderApiFetchParamCreactor = {
    /** 
     * Get the ladder
     * Get the ladder.
     * @param showInactive Include inactive players
     * @param players Include detailed player info
     */
    getLadder(params: {  showInactive?: number; players?: number; }): FetchArgs {
        const baseUrl = `/ladder/json`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "showInactive": params.showInactive,
            "players": params.players,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get the ladder
     * Get the ladder.
     * @param begin Timestamp to filter from.
     * @param end Timestamp to filter to.
     * @param showInactive Include inactive players
     * @param players Include detailed player info
     */
    getLadderBetween(params: {  begin: number; end: number; showInactive?: number; players?: number; }): FetchArgs {
        // verify required parameter "begin" is set
        if (params["begin"] == null) {
            throw new Error("Missing required parameter begin when calling getLadderBetween");
        }
        // verify required parameter "end" is set
        if (params["end"] == null) {
            throw new Error("Missing required parameter end when calling getLadderBetween");
        }
        const baseUrl = `/ladder/{begin}/{end}/json`
            .replace(`{${"begin"}}`, `${ params.begin }`)
            .replace(`{${"end"}}`, `${ params.end }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "showInactive": params.showInactive,
            "players": params.players,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get the ladder
     * Get the ladder.
     * @param showInactive Include inactive players
     * @param players Include detailed player info
     * @param previousGames CSV of speculative games
     */
    speculate(params: {  showInactive?: number; players?: number; previousGames?: string; }): FetchArgs {
        const baseUrl = `/speculate/json`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "showInactive": params.showInactive,
            "players": params.players,
            "previousGames": params.previousGames,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * LadderApi - functional programming interface
 */
export const LadderApiFp = {
    /** 
     * Get the ladder
     * Get the ladder.
     * @param showInactive Include inactive players
     * @param players Include detailed player info
     */
    getLadder(params: { showInactive?: number; players?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<Array<LadderEntry>> {
        const fetchArgs = LadderApiFetchParamCreactor.getLadder(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get the ladder
     * Get the ladder.
     * @param begin Timestamp to filter from.
     * @param end Timestamp to filter to.
     * @param showInactive Include inactive players
     * @param players Include detailed player info
     */
    getLadderBetween(params: { begin: number; end: number; showInactive?: number; players?: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<Array<LadderEntry>> {
        const fetchArgs = LadderApiFetchParamCreactor.getLadderBetween(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get the ladder
     * Get the ladder.
     * @param showInactive Include inactive players
     * @param players Include detailed player info
     * @param previousGames CSV of speculative games
     */
    speculate(params: { showInactive?: number; players?: number; previousGames?: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<Speculated> {
        const fetchArgs = LadderApiFetchParamCreactor.speculate(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * LadderApi - object-oriented interface
 */
export class LadderApi extends BaseAPI {
    /** 
     * Get the ladder
     * Get the ladder.
     * @param showInactive Include inactive players
     * @param players Include detailed player info
     */
    getLadder(params: {  showInactive?: number; players?: number; }) {
        return LadderApiFp.getLadder(params)(this.fetch, this.basePath);
    }
    /** 
     * Get the ladder
     * Get the ladder.
     * @param begin Timestamp to filter from.
     * @param end Timestamp to filter to.
     * @param showInactive Include inactive players
     * @param players Include detailed player info
     */
    getLadderBetween(params: {  begin: number; end: number; showInactive?: number; players?: number; }) {
        return LadderApiFp.getLadderBetween(params)(this.fetch, this.basePath);
    }
    /** 
     * Get the ladder
     * Get the ladder.
     * @param showInactive Include inactive players
     * @param players Include detailed player info
     * @param previousGames CSV of speculative games
     */
    speculate(params: {  showInactive?: number; players?: number; previousGames?: string; }) {
        return LadderApiFp.speculate(params)(this.fetch, this.basePath);
    }
};

/**
 * LadderApi - factory interface
 */
export const LadderApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Get the ladder
         * Get the ladder.
         * @param showInactive Include inactive players
         * @param players Include detailed player info
         */
        getLadder(params: {  showInactive?: number; players?: number; }) {
            return LadderApiFp.getLadder(params)(fetch, basePath);
        },
        /** 
         * Get the ladder
         * Get the ladder.
         * @param begin Timestamp to filter from.
         * @param end Timestamp to filter to.
         * @param showInactive Include inactive players
         * @param players Include detailed player info
         */
        getLadderBetween(params: {  begin: number; end: number; showInactive?: number; players?: number; }) {
            return LadderApiFp.getLadderBetween(params)(fetch, basePath);
        },
        /** 
         * Get the ladder
         * Get the ladder.
         * @param showInactive Include inactive players
         * @param players Include detailed player info
         * @param previousGames CSV of speculative games
         */
        speculate(params: {  showInactive?: number; players?: number; previousGames?: string; }) {
            return LadderApiFp.speculate(params)(fetch, basePath);
        },
    }
};


/**
 * PlayersApi - fetch parameter creator
 */
export const PlayersApiFetchParamCreactor = {
    /** 
     * Get number of active players
     * Get number of active players.
     * @param at CSV of timestamps
     */
    getActive(params: {  at?: string; }): FetchArgs {
        const baseUrl = `/activeplayers/json`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "at": params.at,
        });
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get per player stats
     * Get per player stats.
     * @param player ID of the player
     */
    getPerPlayerStats(params: {  player: string; }): FetchArgs {
        // verify required parameter "player" is set
        if (params["player"] == null) {
            throw new Error("Missing required parameter player when calling getPerPlayerStats");
        }
        const baseUrl = `/player/{player}/perplayerstats/json`
            .replace(`{${"player"}}`, `${ params.player }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get player info
     * Get player info.
     * @param player ID of the player
     */
    getPlayer(params: {  player: string; }): FetchArgs {
        // verify required parameter "player" is set
        if (params["player"] == null) {
            throw new Error("Missing required parameter player when calling getPlayer");
        }
        const baseUrl = `/player/{player}/json`
            .replace(`{${"player"}}`, `${ params.player }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get player&#39;s achievements
     * Get player&#39;s achievements.
     * @param player ID of the player
     */
    getPlayerAchievements(params: {  player: string; }): FetchArgs {
        // verify required parameter "player" is set
        if (params["player"] == null) {
            throw new Error("Missing required parameter player when calling getPlayerAchievements");
        }
        const baseUrl = `/player/{player}/achievements/json`
            .replace(`{${"player"}}`, `${ params.player }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get player&#39;s games
     * Get player&#39;s games.
     * @param player ID of the player
     */
    getPlayerGames(params: {  player: string; }): FetchArgs {
        // verify required parameter "player" is set
        if (params["player"] == null) {
            throw new Error("Missing required parameter player when calling getPlayerGames");
        }
        const baseUrl = `/player/{player}/games/json`
            .replace(`{${"player"}}`, `${ params.player }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * PlayersApi - functional programming interface
 */
export const PlayersApiFp = {
    /** 
     * Get number of active players
     * Get number of active players.
     * @param at CSV of timestamps
     */
    getActive(params: { at?: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<{ [key: string]: ActivePlayers; }> {
        const fetchArgs = PlayersApiFetchParamCreactor.getActive(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get per player stats
     * Get per player stats.
     * @param player ID of the player
     */
    getPerPlayerStats(params: { player: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<Array<PerPlayerStat>> {
        const fetchArgs = PlayersApiFetchParamCreactor.getPerPlayerStats(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get player info
     * Get player info.
     * @param player ID of the player
     */
    getPlayer(params: { player: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<Player> {
        const fetchArgs = PlayersApiFetchParamCreactor.getPlayer(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get player&#39;s achievements
     * Get player&#39;s achievements.
     * @param player ID of the player
     */
    getPlayerAchievements(params: { player: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<Array<Achievement>> {
        const fetchArgs = PlayersApiFetchParamCreactor.getPlayerAchievements(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get player&#39;s games
     * Get player&#39;s games.
     * @param player ID of the player
     */
    getPlayerGames(params: { player: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<Array<Game>> {
        const fetchArgs = PlayersApiFetchParamCreactor.getPlayerGames(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PlayersApi - object-oriented interface
 */
export class PlayersApi extends BaseAPI {
    /** 
     * Get number of active players
     * Get number of active players.
     * @param at CSV of timestamps
     */
    getActive(params: {  at?: string; }) {
        return PlayersApiFp.getActive(params)(this.fetch, this.basePath);
    }
    /** 
     * Get per player stats
     * Get per player stats.
     * @param player ID of the player
     */
    getPerPlayerStats(params: {  player: string; }) {
        return PlayersApiFp.getPerPlayerStats(params)(this.fetch, this.basePath);
    }
    /** 
     * Get player info
     * Get player info.
     * @param player ID of the player
     */
    getPlayer(params: {  player: string; }) {
        return PlayersApiFp.getPlayer(params)(this.fetch, this.basePath);
    }
    /** 
     * Get player&#39;s achievements
     * Get player&#39;s achievements.
     * @param player ID of the player
     */
    getPlayerAchievements(params: {  player: string; }) {
        return PlayersApiFp.getPlayerAchievements(params)(this.fetch, this.basePath);
    }
    /** 
     * Get player&#39;s games
     * Get player&#39;s games.
     * @param player ID of the player
     */
    getPlayerGames(params: {  player: string; }) {
        return PlayersApiFp.getPlayerGames(params)(this.fetch, this.basePath);
    }
};

/**
 * PlayersApi - factory interface
 */
export const PlayersApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Get number of active players
         * Get number of active players.
         * @param at CSV of timestamps
         */
        getActive(params: {  at?: string; }) {
            return PlayersApiFp.getActive(params)(fetch, basePath);
        },
        /** 
         * Get per player stats
         * Get per player stats.
         * @param player ID of the player
         */
        getPerPlayerStats(params: {  player: string; }) {
            return PlayersApiFp.getPerPlayerStats(params)(fetch, basePath);
        },
        /** 
         * Get player info
         * Get player info.
         * @param player ID of the player
         */
        getPlayer(params: {  player: string; }) {
            return PlayersApiFp.getPlayer(params)(fetch, basePath);
        },
        /** 
         * Get player&#39;s achievements
         * Get player&#39;s achievements.
         * @param player ID of the player
         */
        getPlayerAchievements(params: {  player: string; }) {
            return PlayersApiFp.getPlayerAchievements(params)(fetch, basePath);
        },
        /** 
         * Get player&#39;s games
         * Get player&#39;s games.
         * @param player ID of the player
         */
        getPlayerGames(params: {  player: string; }) {
            return PlayersApiFp.getPlayerGames(params)(fetch, basePath);
        },
    }
};


/**
 * StatsApi - fetch parameter creator
 */
export const StatsApiFetchParamCreactor = {
    /** 
     * Get global stats
     * Get global stats.
     */
    getStats(): FetchArgs {
        const baseUrl = `/stats/json`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * StatsApi - functional programming interface
 */
export const StatsApiFp = {
    /** 
     * Get global stats
     * Get global stats.
     */
    getStats(): (fetch: FetchAPI, basePath?: string) => Promise<Stats> {
        const fetchArgs = StatsApiFetchParamCreactor.getStats();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StatsApi - object-oriented interface
 */
export class StatsApi extends BaseAPI {
    /** 
     * Get global stats
     * Get global stats.
     */
    getStats() {
        return StatsApiFp.getStats()(this.fetch, this.basePath);
    }
};

/**
 * StatsApi - factory interface
 */
export const StatsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Get global stats
         * Get global stats.
         */
        getStats() {
            return StatsApiFp.getStats()(fetch, basePath);
        },
    }
};

